/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  CouponCalculationMetadataDto,
  CouponCalculationMetadataDto$inboundSchema,
} from "./couponcalculationmetadatadto.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  InvoiceStatusEnum,
  InvoiceStatusEnum$inboundSchema,
} from "./invoicestatusenum.js";
import { InvoiceType, InvoiceType$inboundSchema } from "./invoicetype.js";
import { PaymentFlow, PaymentFlow$inboundSchema } from "./paymentflow.js";
import {
  PaymentMethodEnum,
  PaymentMethodEnum$inboundSchema,
} from "./paymentmethodenum.js";
import {
  RecurringInterval,
  RecurringInterval$inboundSchema,
} from "./recurringinterval.js";

export type InvoiceBase = {
  /**
   * Creation timestamp of the object.
   */
  createdAt: Date;
  /**
   * Last modification timestamp of the object.
   */
  updatedAt: Date | null;
  id: string;
  userId: string;
  organizationId: string;
  organizationConsumerId: string;
  accountId: string;
  branchId: string;
  orgInvoiceNumber: number;
  description?: string | null | undefined;
  totalAmount: string;
  originalAmount: string;
  itemLevelDiscountedAmount: string;
  /**
   * Total VAT amount calculated from products
   */
  totalVatAmount?: string | null | undefined;
  /**
   * Total price excluding VAT
   */
  totalPriceExcludingVat?: string | null | undefined;
  /**
   * Metadata about how coupons were applied to the invoice
   */
  couponCalculationMetadata?: CouponCalculationMetadataDto | null | undefined;
  currency?: string | null | undefined;
  consumerMessage?: string | null | undefined;
  /**
   * Invoice status enum representing the lifecycle/state of an invoice.
   *
   * @remarks
   *
   * Status describes the current stage of an invoice in its lifecycle (DRAFT → CREATED → SENT → ACCEPTED → COMPLETED).
   * This changes over time as the invoice progresses. Different from InvoiceType which describes the payment structure.
   */
  status: InvoiceStatusEnum;
  paymentMethod: PaymentMethodEnum;
  allowedPaymentFlow: PaymentFlow;
  currentPaymentFlow?: PaymentFlow | null | undefined;
  periodStart?: Date | null | undefined;
  periodEnd?: Date | null | undefined;
  recurringInterval?: RecurringInterval | null | undefined;
  recurringIntervalCount?: number | null | undefined;
  type?: InvoiceType | null | undefined;
};

/** @internal */
export const InvoiceBase$inboundSchema: z.ZodMiniType<InvoiceBase, unknown> = z
  .pipe(
    z.object({
      created_at: types.date(),
      updated_at: types.nullable(types.date()),
      id: types.string(),
      user_id: types.string(),
      organization_id: types.string(),
      organization_consumer_id: types.string(),
      account_id: types.string(),
      branch_id: types.string(),
      org_invoice_number: types.number(),
      description: z.optional(z.nullable(types.string())),
      total_amount: types.string(),
      original_amount: types.string(),
      item_level_discounted_amount: types.string(),
      total_vat_amount: z.optional(z.nullable(types.string())),
      total_price_excluding_vat: z.optional(z.nullable(types.string())),
      coupon_calculation_metadata: z.optional(
        z.nullable(CouponCalculationMetadataDto$inboundSchema),
      ),
      currency: z.optional(z.nullable(types.string())),
      consumer_message: z.optional(z.nullable(types.string())),
      status: InvoiceStatusEnum$inboundSchema,
      payment_method: PaymentMethodEnum$inboundSchema,
      allowed_payment_flow: PaymentFlow$inboundSchema,
      current_payment_flow: z.optional(z.nullable(PaymentFlow$inboundSchema)),
      period_start: z.optional(z.nullable(types.date())),
      period_end: z.optional(z.nullable(types.date())),
      recurring_interval: z.optional(
        z.nullable(RecurringInterval$inboundSchema),
      ),
      recurring_interval_count: z.optional(z.nullable(types.number())),
      type: z.optional(z.nullable(InvoiceType$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "user_id": "userId",
        "organization_id": "organizationId",
        "organization_consumer_id": "organizationConsumerId",
        "account_id": "accountId",
        "branch_id": "branchId",
        "org_invoice_number": "orgInvoiceNumber",
        "total_amount": "totalAmount",
        "original_amount": "originalAmount",
        "item_level_discounted_amount": "itemLevelDiscountedAmount",
        "total_vat_amount": "totalVatAmount",
        "total_price_excluding_vat": "totalPriceExcludingVat",
        "coupon_calculation_metadata": "couponCalculationMetadata",
        "consumer_message": "consumerMessage",
        "payment_method": "paymentMethod",
        "allowed_payment_flow": "allowedPaymentFlow",
        "current_payment_flow": "currentPaymentFlow",
        "period_start": "periodStart",
        "period_end": "periodEnd",
        "recurring_interval": "recurringInterval",
        "recurring_interval_count": "recurringIntervalCount",
      });
    }),
  );

export function invoiceBaseFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceBase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceBase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceBase' from JSON`,
  );
}
