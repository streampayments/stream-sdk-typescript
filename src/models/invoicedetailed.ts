/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  AppCommonDtosSharedOrganizationConsumer,
  AppCommonDtosSharedOrganizationConsumer$inboundSchema,
} from "./appcommondtossharedorganizationconsumer.js";
import { BranchDto, BranchDto$inboundSchema } from "./branchdto.js";
import {
  CouponCalculationMetadataDto,
  CouponCalculationMetadataDto$inboundSchema,
} from "./couponcalculationmetadatadto.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  InvoiceItemDto,
  InvoiceItemDto$inboundSchema,
} from "./invoiceitemdto.js";
import {
  InvoicePaymentMethodDto,
  InvoicePaymentMethodDto$inboundSchema,
} from "./invoicepaymentmethoddto.js";
import {
  InvoiceStatusEnum,
  InvoiceStatusEnum$inboundSchema,
} from "./invoicestatusenum.js";
import { InvoiceType, InvoiceType$inboundSchema } from "./invoicetype.js";
import { PaymentDto, PaymentDto$inboundSchema } from "./paymentdto.js";
import { PaymentFlow, PaymentFlow$inboundSchema } from "./paymentflow.js";
import {
  PaymentMethodEnum,
  PaymentMethodEnum$inboundSchema,
} from "./paymentmethodenum.js";
import {
  RecurrencePattern,
  RecurrencePattern$inboundSchema,
} from "./recurrencepattern.js";
import {
  RecurringInterval,
  RecurringInterval$inboundSchema,
} from "./recurringinterval.js";
import {
  SubscriptionDetailed,
  SubscriptionDetailed$inboundSchema,
} from "./subscriptiondetailed.js";

export type InvoiceDetailed = {
  /**
   * Creation timestamp of the object.
   */
  createdAt: Date;
  /**
   * Last modification timestamp of the object.
   */
  updatedAt: Date | null;
  id: string;
  userId: string;
  organizationId: string;
  organizationConsumerId: string;
  accountId: string;
  branchId: string;
  orgInvoiceNumber: number;
  description?: string | null | undefined;
  totalAmount: string;
  originalAmount: string;
  itemLevelDiscountedAmount: string;
  /**
   * Total VAT amount calculated from products
   */
  totalVatAmount?: string | null | undefined;
  /**
   * Total price excluding VAT
   */
  totalPriceExcludingVat?: string | null | undefined;
  /**
   * Metadata about how coupons were applied to the invoice
   */
  couponCalculationMetadata?: CouponCalculationMetadataDto | null | undefined;
  currency?: string | null | undefined;
  consumerMessage?: string | null | undefined;
  /**
   * Invoice status enum representing the lifecycle/state of an invoice.
   *
   * @remarks
   *
   * Status describes the current stage of an invoice in its lifecycle (DRAFT → CREATED → SENT → ACCEPTED → COMPLETED).
   * This changes over time as the invoice progresses. Different from InvoiceType which describes the payment structure.
   */
  status: InvoiceStatusEnum;
  paymentMethod: PaymentMethodEnum;
  allowedPaymentFlow: PaymentFlow;
  currentPaymentFlow?: PaymentFlow | null | undefined;
  periodStart?: Date | null | undefined;
  periodEnd?: Date | null | undefined;
  recurringInterval?: RecurringInterval | null | undefined;
  recurringIntervalCount?: number | null | undefined;
  type?: InvoiceType | null | undefined;
  /**
   * Global unique invoice number
   */
  invoiceNumber: number;
  /**
   * Remaining amount to be paid
   */
  remainingAmount: string;
  /**
   * Total amount already paid
   */
  paidAmount: string;
  excludeCouponsIfInstallments: boolean;
  organizationConsumer: AppCommonDtosSharedOrganizationConsumer;
  items: Array<InvoiceItemDto>;
  branch?: BranchDto | null | undefined;
  payments: Array<PaymentDto>;
  subscriptionId?: string | null | undefined;
  subscription?: SubscriptionDetailed | null | undefined;
  paymentMethods?: InvoicePaymentMethodDto | null | undefined;
  /**
   * Recurrence pattern for recurring invoices
   */
  recurrencePattern?: RecurrencePattern | null | undefined;
  /**
   * Parent invoice ID for recurring invoices
   */
  parentId?: string | null | undefined;
  customFieldAnswers?: { [k: string]: any } | null | undefined;
  url: string;
};

/** @internal */
export const InvoiceDetailed$inboundSchema: z.ZodMiniType<
  InvoiceDetailed,
  unknown
> = z.pipe(
  z.object({
    created_at: types.date(),
    updated_at: types.nullable(types.date()),
    id: types.string(),
    user_id: types.string(),
    organization_id: types.string(),
    organization_consumer_id: types.string(),
    account_id: types.string(),
    branch_id: types.string(),
    org_invoice_number: types.number(),
    description: z.optional(z.nullable(types.string())),
    total_amount: types.string(),
    original_amount: types.string(),
    item_level_discounted_amount: types.string(),
    total_vat_amount: z.optional(z.nullable(types.string())),
    total_price_excluding_vat: z.optional(z.nullable(types.string())),
    coupon_calculation_metadata: z.optional(
      z.nullable(CouponCalculationMetadataDto$inboundSchema),
    ),
    currency: z.optional(z.nullable(types.string())),
    consumer_message: z.optional(z.nullable(types.string())),
    status: InvoiceStatusEnum$inboundSchema,
    payment_method: PaymentMethodEnum$inboundSchema,
    allowed_payment_flow: PaymentFlow$inboundSchema,
    current_payment_flow: z.optional(z.nullable(PaymentFlow$inboundSchema)),
    period_start: z.optional(z.nullable(types.date())),
    period_end: z.optional(z.nullable(types.date())),
    recurring_interval: z.optional(z.nullable(RecurringInterval$inboundSchema)),
    recurring_interval_count: z.optional(z.nullable(types.number())),
    type: z.optional(z.nullable(InvoiceType$inboundSchema)),
    invoice_number: types.number(),
    remaining_amount: types.string(),
    paid_amount: types.string(),
    exclude_coupons_if_installments: types.boolean(),
    organization_consumer:
      AppCommonDtosSharedOrganizationConsumer$inboundSchema,
    items: z.array(InvoiceItemDto$inboundSchema),
    branch: z.optional(z.nullable(BranchDto$inboundSchema)),
    payments: z.array(PaymentDto$inboundSchema),
    subscription_id: z.optional(z.nullable(types.string())),
    subscription: z.optional(z.nullable(SubscriptionDetailed$inboundSchema)),
    payment_methods: z.optional(
      z.nullable(InvoicePaymentMethodDto$inboundSchema),
    ),
    recurrence_pattern: z.optional(z.nullable(RecurrencePattern$inboundSchema)),
    parent_id: z.optional(z.nullable(types.string())),
    custom_field_answers: z.optional(z.nullable(z.record(z.string(), z.any()))),
    url: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "updated_at": "updatedAt",
      "user_id": "userId",
      "organization_id": "organizationId",
      "organization_consumer_id": "organizationConsumerId",
      "account_id": "accountId",
      "branch_id": "branchId",
      "org_invoice_number": "orgInvoiceNumber",
      "total_amount": "totalAmount",
      "original_amount": "originalAmount",
      "item_level_discounted_amount": "itemLevelDiscountedAmount",
      "total_vat_amount": "totalVatAmount",
      "total_price_excluding_vat": "totalPriceExcludingVat",
      "coupon_calculation_metadata": "couponCalculationMetadata",
      "consumer_message": "consumerMessage",
      "payment_method": "paymentMethod",
      "allowed_payment_flow": "allowedPaymentFlow",
      "current_payment_flow": "currentPaymentFlow",
      "period_start": "periodStart",
      "period_end": "periodEnd",
      "recurring_interval": "recurringInterval",
      "recurring_interval_count": "recurringIntervalCount",
      "invoice_number": "invoiceNumber",
      "remaining_amount": "remainingAmount",
      "paid_amount": "paidAmount",
      "exclude_coupons_if_installments": "excludeCouponsIfInstallments",
      "organization_consumer": "organizationConsumer",
      "subscription_id": "subscriptionId",
      "payment_methods": "paymentMethods",
      "recurrence_pattern": "recurrencePattern",
      "parent_id": "parentId",
      "custom_field_answers": "customFieldAnswers",
    });
  }),
);

export function invoiceDetailedFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceDetailed, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceDetailed$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceDetailed' from JSON`,
  );
}
