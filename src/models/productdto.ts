/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { ProductType, ProductType$inboundSchema } from "./producttype.js";
import {
  RecurringInterval,
  RecurringInterval$inboundSchema,
} from "./recurringinterval.js";

/**
 * Price currency of the product.
 */
export const Currency = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Bov: "BOV",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byn: "BYN",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Che: "CHE",
  Chf: "CHF",
  Chw: "CHW",
  Clf: "CLF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Cou: "COU",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mru: "MRU",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Mxv: "MXV",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sle: "SLE",
  Sll: "SLL",
  Sos: "SOS",
  Srd: "SRD",
  Ssp: "SSP",
  Stn: "STN",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Usn: "USN",
  Uyi: "UYI",
  Uyu: "UYU",
  Uyw: "UYW",
  Uzs: "UZS",
  Ved: "VED",
  Ves: "VES",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xof: "XOF",
  Xpf: "XPF",
  Xsu: "XSU",
  Xua: "XUA",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwl: "ZWL",
} as const;
/**
 * Price currency of the product.
 */
export type Currency = OpenEnum<typeof Currency>;

export type ProductDto = {
  /**
   * Creation timestamp of the object.
   */
  createdAt: Date;
  /**
   * Last modification timestamp of the object.
   */
  updatedAt: Date | null;
  id: string;
  /**
   * Name of the product.
   */
  name: string;
  /**
   * Description of the product.
   */
  description?: string | null | undefined;
  type: ProductType;
  /**
   * Represents the billing cycle interval if product is recurring
   */
  recurringInterval?: RecurringInterval | null | undefined;
  /**
   * The billing cycle multiple if the product is recurring
   */
  recurringIntervalCount: number;
  /**
   * Total price including VAT.
   */
  price: string;
  /**
   * Price currency of the product.
   */
  currency?: Currency | undefined;
  /**
   * Can this product be used in invoices or subscriptions?
   */
  isActive: boolean;
  /**
   * Shows if the product was created to be used once, and not to be added to product cataloge
   */
  isOneTime: boolean;
  /**
   * Is the price exempt from VAT?
   */
  isPriceExemptFromVat: boolean;
  /**
   * Is the price inclusive of VAT?
   */
  isPriceInclusiveOfVat: boolean;
  /**
   * Price excluding VAT.
   */
  priceExcludingVat: string;
  /**
   * VAT amount.
   */
  vatAmount: string;
  /**
   * Is the product used in a finalized invoice?
   */
  isUsedInFinalizedInvoice?: boolean | undefined;
};

/** @internal */
export const Currency$inboundSchema: z.ZodMiniType<Currency, unknown> =
  openEnums.inboundSchema(Currency);

/** @internal */
export const ProductDto$inboundSchema: z.ZodMiniType<ProductDto, unknown> = z
  .pipe(
    z.object({
      created_at: types.date(),
      updated_at: types.nullable(types.date()),
      id: types.string(),
      name: types.string(),
      description: z.optional(z.nullable(types.string())),
      type: ProductType$inboundSchema,
      recurring_interval: z.optional(
        z.nullable(RecurringInterval$inboundSchema),
      ),
      recurring_interval_count: types.number(),
      price: types.string(),
      currency: z._default(Currency$inboundSchema, "SAR"),
      is_active: types.boolean(),
      is_one_time: types.boolean(),
      is_price_exempt_from_vat: types.boolean(),
      is_price_inclusive_of_vat: types.boolean(),
      price_excluding_vat: types.string(),
      vat_amount: types.string(),
      is_used_in_finalized_invoice: z._default(types.boolean(), false),
    }),
    z.transform((v) => {
      return remap$(v, {
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "recurring_interval": "recurringInterval",
        "recurring_interval_count": "recurringIntervalCount",
        "is_active": "isActive",
        "is_one_time": "isOneTime",
        "is_price_exempt_from_vat": "isPriceExemptFromVat",
        "is_price_inclusive_of_vat": "isPriceInclusiveOfVat",
        "price_excluding_vat": "priceExcludingVat",
        "vat_amount": "vatAmount",
        "is_used_in_finalized_invoice": "isUsedInFinalizedInvoice",
      });
    }),
  );

export function productDtoFromJSON(
  jsonString: string,
): SafeParseResult<ProductDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProductDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProductDto' from JSON`,
  );
}
