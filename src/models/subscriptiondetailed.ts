/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  AppSubscriptionV2DtosOrganizationConsumer,
  AppSubscriptionV2DtosOrganizationConsumer$inboundSchema,
} from "./appsubscriptionv2dtosorganizationconsumer.js";
import {
  CouponCalculationMetadataDto,
  CouponCalculationMetadataDto$inboundSchema,
} from "./couponcalculationmetadatadto.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  FreezeSubscriptionBase,
  FreezeSubscriptionBase$inboundSchema,
} from "./freezesubscriptionbase.js";
import { InvoiceBase, InvoiceBase$inboundSchema } from "./invoicebase.js";
import {
  SubscriptionItemDto,
  SubscriptionItemDto$inboundSchema,
} from "./subscriptionitemdto.js";
import {
  SubscriptionPaymentMethodDto,
  SubscriptionPaymentMethodDto$inboundSchema,
} from "./subscriptionpaymentmethoddto.js";
import {
  SubscriptionRecurringInterval,
  SubscriptionRecurringInterval$inboundSchema,
} from "./subscriptionrecurringinterval.js";
import {
  SubscriptionStatus,
  SubscriptionStatus$inboundSchema,
} from "./subscriptionstatus.js";

export type SubscriptionDetailed = {
  /**
   * Creation timestamp of the object.
   */
  createdAt: Date;
  /**
   * Last modification timestamp of the object.
   */
  updatedAt: Date | null;
  id: string;
  description?: string | null | undefined;
  amount: string;
  originalAmount: string;
  itemLevelDiscountedAmount: string;
  /**
   * Metadata about how coupons were applied to the subscription
   */
  couponCalculationMetadata?: CouponCalculationMetadataDto | null | undefined;
  remainingDays: number;
  currency: string;
  recurringInterval: SubscriptionRecurringInterval;
  recurringIntervalCount: number;
  status: SubscriptionStatus;
  currentPeriodStart: Date;
  currentPeriodEnd: Date;
  currentCycleNumber: number;
  cancelAtPeriodEnd: boolean;
  cancelAtCycleNumber?: number | null | undefined;
  startedAt?: Date | null | undefined;
  endedAt?: Date | null | undefined;
  userId: string;
  organizationConsumerId: string;
  latestInvoiceId?: string | null | undefined;
  organizationConsumer?:
    | AppSubscriptionV2DtosOrganizationConsumer
    | null
    | undefined;
  items?: Array<SubscriptionItemDto> | null | undefined;
  latestInvoice?: InvoiceBase | null | undefined;
  latestFreeze?: FreezeSubscriptionBase | null | undefined;
  overridePaymentMethods?: SubscriptionPaymentMethodDto | null | undefined;
};

/** @internal */
export const SubscriptionDetailed$inboundSchema: z.ZodMiniType<
  SubscriptionDetailed,
  unknown
> = z.pipe(
  z.object({
    created_at: types.date(),
    updated_at: types.nullable(types.date()),
    id: types.string(),
    description: z.optional(z.nullable(types.string())),
    amount: types.string(),
    original_amount: types.string(),
    item_level_discounted_amount: types.string(),
    coupon_calculation_metadata: z.optional(
      z.nullable(CouponCalculationMetadataDto$inboundSchema),
    ),
    remaining_days: types.number(),
    currency: types.string(),
    recurring_interval: SubscriptionRecurringInterval$inboundSchema,
    recurring_interval_count: types.number(),
    status: SubscriptionStatus$inboundSchema,
    current_period_start: types.date(),
    current_period_end: types.date(),
    current_cycle_number: types.number(),
    cancel_at_period_end: types.boolean(),
    cancel_at_cycle_number: z.optional(z.nullable(types.number())),
    started_at: z.optional(z.nullable(types.date())),
    ended_at: z.optional(z.nullable(types.date())),
    user_id: types.string(),
    organization_consumer_id: types.string(),
    latest_invoice_id: z.optional(z.nullable(types.string())),
    organization_consumer: z.optional(
      z.nullable(AppSubscriptionV2DtosOrganizationConsumer$inboundSchema),
    ),
    items: z.optional(z.nullable(z.array(SubscriptionItemDto$inboundSchema))),
    latest_invoice: z.optional(z.nullable(InvoiceBase$inboundSchema)),
    latest_freeze: z.optional(z.nullable(FreezeSubscriptionBase$inboundSchema)),
    override_payment_methods: z.optional(
      z.nullable(SubscriptionPaymentMethodDto$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "updated_at": "updatedAt",
      "original_amount": "originalAmount",
      "item_level_discounted_amount": "itemLevelDiscountedAmount",
      "coupon_calculation_metadata": "couponCalculationMetadata",
      "remaining_days": "remainingDays",
      "recurring_interval": "recurringInterval",
      "recurring_interval_count": "recurringIntervalCount",
      "current_period_start": "currentPeriodStart",
      "current_period_end": "currentPeriodEnd",
      "current_cycle_number": "currentCycleNumber",
      "cancel_at_period_end": "cancelAtPeriodEnd",
      "cancel_at_cycle_number": "cancelAtCycleNumber",
      "started_at": "startedAt",
      "ended_at": "endedAt",
      "user_id": "userId",
      "organization_consumer_id": "organizationConsumerId",
      "latest_invoice_id": "latestInvoiceId",
      "organization_consumer": "organizationConsumer",
      "latest_invoice": "latestInvoice",
      "latest_freeze": "latestFreeze",
      "override_payment_methods": "overridePaymentMethods",
    });
  }),
);

export function subscriptionDetailedFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionDetailed, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionDetailed$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionDetailed' from JSON`,
  );
}
